package aspguidp.service.input.suggestion.impl;

import aspguidp.helper.TemplateHelper;
import aspguidp.helper.ValueSourceHelper;
import aspguidp.service.core.CoreServicePool;
import aspguidp.service.core.atom.Atom;
import aspguidp.service.data.template.TemplatePart;
import aspguidp.service.input.suggestion.SuggestionService;
import aspguidp.service.input.validation.ValidationService;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Implementation of the {@link SuggestionService} interface which generates suggestions and prompt texts based on a
 * sequence of {@link TemplatePart} instances.
 * <p>
 * An instance of the class is initialized with a sequence of template parts. This sequence of template parts is
 * used for the generation of suggestions and prompt texts for a given user input by the service.
 * <p>
 * Suggestions generated by an instance of this service always suggest the value for exactly one placeholder template
 * part. Therefore a suggestion generated by this service can be split up into 3 parts: fixed start, suggested
 * placeholder value and fixed end.
 */
public class TemplateSuggestionService implements SuggestionService {
    private final List<TemplatePart> templateParts;
    private final ValidationService validationService;

    /**
     * Create a new service instance for the given sequence of template parts.
     * The given validation service is used to validate given user input.
     * <p>
     * If a given user input is validated as invalid by the given validation service, empty suggestions and prompt
     * texts are returned for the user input.
     *
     * @param templateParts     sequence of template pats which is used to generate suggestions and prompt texts
     * @param validationService service which is used to validate given user inputs
     */
    public TemplateSuggestionService(List<TemplatePart> templateParts, ValidationService validationService) {
        this.templateParts = templateParts;
        this.validationService = validationService;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<String> getSuggestions(String input) {
        if (this.validationService.validate(input) == ValidationService.ValidationStatus.INVALID)
            return Collections.emptyList();

        // get fixed start part of suggestion
        String fixedSuggestionStart = this.getFixedSuggestionStart(input);
        List<TemplatePart> coveredParts = TemplateHelper.getMatchingTemplateParts(fixedSuggestionStart, this.templateParts);

        // if first not covered part is a placeholder part, get suggestions values for placeholder
        List<String> placeholderSuggestions = Collections.singletonList("");
        if (this.templateParts.size() > coveredParts.size() && this.templateParts.get(coveredParts.size()).isPlaceholderPart()) {
            String placeholderValueSource = this.templateParts.get(coveredParts.size()).getPlaceholderValueSource();
            String currentPlaceholderValue = input.substring(TemplateHelper.getMatchEndPosition(input, coveredParts));
            placeholderSuggestions = this.getPossiblePlaceholderValues(currentPlaceholderValue, placeholderValueSource);
            coveredParts.add(this.templateParts.get(coveredParts.size()));
        }

        // get fixed end part of suggestion
        String fixedSuggestionEnd = this.getFixedSuggestionEnd(coveredParts);

        // construct suggestions by concatenating fixed parts with sorted suggestions
        Stream<String> suggestionStream = placeholderSuggestions.stream().sorted();
        return suggestionStream.map(s -> fixedSuggestionStart + s + fixedSuggestionEnd).collect(Collectors.toList());
    }

    /**
     * Extract the fixed part of a given input string. The fixed part of an input is the sequence of characters from
     * the start of the input, which stays the same in every suggestion.
     * <p>
     * For example: the fixed part of the input 'edge(alpha,b' is 'edge(alpha,', as every suggestion for this input
     * must start with this fixed part.
     *
     * @param input user input string from which the fixed part is extracted
     * @return fixed part extracted from the given user input
     */
    private String getFixedSuggestionStart(String input) {
        List<TemplatePart> matchingParts = TemplateHelper.getMatchingTemplateParts(input, this.templateParts);

        // if there is an unmatched part at the end of the input, the user cannot change the matching parts anymore
        // therefore return the matching input as fixed
        if (!input.substring(TemplateHelper.getMatchEndPosition(input, matchingParts)).isEmpty()) {
            return input.substring(0, TemplateHelper.getMatchEndPosition(input, matchingParts));
        }

        // if last matched part is a placeholder part, user can still change the placeholder value
        // therefore remove placeholder part from matching parts
        TemplatePart lastMatchedPart = (!matchingParts.isEmpty()) ? matchingParts.get(matchingParts.size() - 1) : null;
        if (lastMatchedPart != null && lastMatchedPart.isPlaceholderPart()) {
            matchingParts.remove(lastMatchedPart);
        }

        // return fixed part of the input
        return input.substring(0, TemplateHelper.getMatchEndPosition(input, matchingParts));
    }

    /**
     * Get possible placeholder values from the given value source while minding the current placeholder value.
     * A possible placeholder value must be a value of the value source and start with the given current placeholder
     * value.
     * <p>
     * If the given value source is empty, the given current placeholder value is returned as possible value.
     *
     * @param currentPlaceholderValue current placeholder value which is used to extract possible values
     * @param placeholderValueSource  value source from which possible values are extracted
     * @return list of possible placeholder values
     */
    private List<String> getPossiblePlaceholderValues(String currentPlaceholderValue, String placeholderValueSource) {
        // if value source is empty, every value is valid
        if (placeholderValueSource.isEmpty()) {
            if (currentPlaceholderValue.isEmpty()) return Collections.emptyList();
            return Collections.singletonList(currentPlaceholderValue);
        }

        Collection<Atom> currentInputAtoms = CoreServicePool.getInstance().getInputAtomHub().getAtomsFromSuppliers();
        return ValueSourceHelper.getValues(currentInputAtoms, placeholderValueSource, currentPlaceholderValue);
    }

    /**
     * Get the fixed end part for a suggestion based on the sequence of template parts which are already covered by
     * the suggestion.
     * <p>
     * The fixed end part of a suggestion includes every not covered template part until the nex placeholder template
     * part.
     *
     * @param coveredParts sequence of template parts which is already covered by the suggestion
     * @return fixed end part for a suggestion which covers the given sequence of template parts
     */
    private String getFixedSuggestionEnd(List<TemplatePart> coveredParts) {
        String fixedSuggestionEnd = "";
        for (int i = coveredParts.size(); i < this.templateParts.size(); i++) {
            if (this.templateParts.get(i).isPlaceholderPart()) break;
            fixedSuggestionEnd = fixedSuggestionEnd + this.templateParts.get(i).getDisplayValue();
        }
        return fixedSuggestionEnd;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String getPromptText(String input) {
        if (this.validationService.validate(input) == ValidationService.ValidationStatus.INVALID) return "";

        // get matched template parts and matched input string
        List<TemplatePart> matchingParts = TemplateHelper.getMatchingTemplateParts(input, this.templateParts);
        String matchedString = input.substring(0, TemplateHelper.getMatchEndPosition(input, matchingParts));

        // use not matched part for constructing remaining string
        String remainingString = "";
        for (int i = matchingParts.size(); i < this.templateParts.size(); i++) {
            remainingString = remainingString + this.templateParts.get(i).getDisplayValue();
        }

        return matchedString + remainingString;
    }
}
